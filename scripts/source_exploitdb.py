#!/usr/bin/env python3
"""
GLADIATOR Exploit-DB Scraper
Sources real exploit code from Exploit-DB for 1,436 CISA KEV CVEs
"""

import json
import os
import sys
import requests
import time
from pathlib import Path
from datetime import datetime
import subprocess

# Configuration
CISA_KEV_FILE = "/Users/arthurdell/GLADIATOR/datasets/current_threats/cisa_kev_oct2025.json"
EXPLOIT_DIR = "/Users/arthurdell/GLADIATOR/datasets/exploit_database/"
OUTPUT_DIR = "/Users/arthurdell/GLADIATOR/datasets/exploitdb_code/"
LOG_FILE = "/Users/arthurdell/GLADIATOR/logs/exploitdb_sourcing.log"

# Exploit-DB searchsploit (comes with Kali, can install separately)
SEARCHSPLOIT_CMD = "searchsploit"

def log(message):
    """Log to file and stdout"""
    timestamp = datetime.now().isoformat()
    log_msg = f"[{timestamp}] {message}"
    print(log_msg, flush=True)
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_msg + '\n')

def check_searchsploit():
    """Check if searchsploit is installed"""
    try:
        result = subprocess.run(['which', 'searchsploit'], 
                              capture_output=True, text=True, timeout=5)
        if result.returncode == 0:
            log(f"✅ searchsploit found: {result.stdout.strip()}")
            return True
        else:
            log("❌ searchsploit not found. Install: brew install exploitdb")
            return False
    except Exception as e:
        log(f"❌ Error checking searchsploit: {e}")
        return False

def search_exploit_db_cli(cve_id):
    """Search Exploit-DB using searchsploit CLI"""
    try:
        # searchsploit -j CVE-2021-43798 (JSON output)
        result = subprocess.run(
            ['searchsploit', '-j', cve_id],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if result.returncode == 0:
            data = json.loads(result.stdout)
            results = data.get('RESULTS_EXPLOIT', [])
            if results:
                log(f"  {cve_id}: Found {len(results)} exploit(s) in Exploit-DB")
                return results
        
        return []
    except Exception as e:
        log(f"  {cve_id}: Error searching: {e}")
        return []

def get_exploit_code(exploit_path):
    """Get exploit code from Exploit-DB path"""
    try:
        # Exploit-DB paths are like: exploits/linux/remote/12345.py
        # Full path typically: /usr/share/exploitdb/exploits/...
        result = subprocess.run(
            ['searchsploit', '-x', exploit_path],
            capture_output=True,
            text=True,
            timeout=10
        )
        
        if result.returncode == 0:
            return result.stdout
        return None
    except Exception as e:
        log(f"    Error getting exploit code: {e}")
        return None

def search_exploit_db_web(cve_id):
    """Fallback: Search Exploit-DB website"""
    try:
        # Exploit-DB web search API
        url = f"https://www.exploit-db.com/search?cve={cve_id}"
        headers = {'User-Agent': 'Mozilla/5.0'}
        
        response = requests.get(url, headers=headers, timeout=15)
        
        if response.status_code == 200:
            # Parse HTML for exploit IDs (would need BeautifulSoup)
            # For now, just log that we found the page
            log(f"  {cve_id}: Found on Exploit-DB web (manual extraction needed)")
            return {'url': url, 'status': 'found'}
        
        return None
    except Exception as e:
        log(f"  {cve_id}: Web search error: {e}")
        return None

def process_cve(cve_id):
    """Process one CVE to find exploit code"""
    output_file = Path(OUTPUT_DIR) / f"{cve_id}_exploitdb.json"
    
    if output_file.exists():
        log(f"  {cve_id}: Already processed, skipping")
        return True
    
    log(f"  {cve_id}: Searching Exploit-DB...")
    
    # Try CLI first (if available)
    exploits = search_exploit_db_cli(cve_id)
    
    if exploits:
        # Get actual exploit code
        exploit_codes = []
        for exp in exploits[:5]:  # Limit to 5 per CVE
            path = exp.get('Path', '')
            if path:
                code = get_exploit_code(path)
                if code:
                    exploit_codes.append({
                        'title': exp.get('Title', ''),
                        'path': path,
                        'date': exp.get('Date_Published', ''),
                        'code': code,
                        'type': exp.get('Type', '')
                    })
        
        if exploit_codes:
            # Save exploit data
            os.makedirs(OUTPUT_DIR, exist_ok=True)
            data = {
                'cve': cve_id,
                'source': 'exploit-db',
                'exploit_count': len(exploit_codes),
                'exploits': exploit_codes,
                'retrieved_at': datetime.now().isoformat(),
                'ready_for_variants': True
            }
            
            with open(output_file, 'w') as f:
                json.dump(data, f, indent=2)
            
            log(f"  {cve_id}: ✅ Saved {len(exploit_codes)} exploit(s)")
            return True
    
    # Fallback: Try web search
    web_result = search_exploit_db_web(cve_id)
    if web_result:
        data = {
            'cve': cve_id,
            'source': 'exploit-db-web',
            'web_url': web_result.get('url'),
            'retrieved_at': datetime.now().isoformat(),
            'ready_for_variants': False,
            'note': 'Manual extraction needed'
        }
        
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
        
        log(f"  {cve_id}: ⚠️ Found on web (needs manual extraction)")
        return True
    
    # Not found
    log(f"  {cve_id}: ❌ Not found in Exploit-DB")
    return False

def main():
    """Main execution"""
    log("="*80)
    log("GLADIATOR EXPLOIT-DB SOURCING")
    log("="*80)
    
    # Check if searchsploit is available
    has_searchsploit = check_searchsploit()
    
    if not has_searchsploit:
        log("\n⚠️  searchsploit not found. Install with:")
        log("    brew install exploitdb")
        log("\nContinuing with web search fallback...\n")
    
    # Load CVEs
    log(f"\nLoading CISA KEV from {CISA_KEV_FILE}")
    with open(CISA_KEV_FILE) as f:
        data = json.load(f)
    
    vulns = data.get('vulnerabilities', [])
    cves = [v.get('cveID') for v in vulns]
    
    log(f"Found {len(cves)} CVEs to process\n")
    
    # Process each CVE
    found = 0
    not_found = 0
    
    for i, cve in enumerate(cves, 1):
        log(f"[{i}/{len(cves)}] {cve}")
        
        if process_cve(cve):
            found += 1
        else:
            not_found += 1
        
        # Rate limit
        if i % 10 == 0:
            log(f"  Progress: {i}/{len(cves)} ({i*100//len(cves)}%)")
            log(f"  Found: {found}, Not found: {not_found}\n")
            time.sleep(1)
    
    log("\n" + "="*80)
    log("EXPLOIT-DB SOURCING COMPLETE")
    log(f"Total CVEs: {len(cves)}")
    log(f"Exploits found: {found}")
    log(f"Not found: {not_found}")
    log(f"Success rate: {found*100//len(cves)}%")
    log("="*80)
    
    return found

if __name__ == "__main__":
    try:
        count = main()
        sys.exit(0 if count > 0 else 1)
    except KeyboardInterrupt:
        log("\n\nSourcing interrupted by user")
        sys.exit(130)
    except Exception as e:
        log(f"\n\nFATAL ERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

