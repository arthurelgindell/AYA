#!/usr/bin/env python3
"""
GLADIATOR CVE-to-Exploit Matcher
Matches 1,436 CISA KEV CVEs to actual exploit code in Exploit-DB repo
"""

import json
import os
import sys
import re
from pathlib import Path
from datetime import datetime

# Configuration
CISA_KEV_FILE = "/Users/arthurdell/GLADIATOR/datasets/current_threats/cisa_kev_oct2025.json"
EXPLOITDB_DIR = "/Users/arthurdell/GLADIATOR/datasets/exploit-database"
OUTPUT_DIR = "/Users/arthurdell/GLADIATOR/datasets/matched_exploits/"
LOG_FILE = "/Users/arthurdell/GLADIATOR/logs/cve_matching.log"

def log(message):
    """Log to file and stdout"""
    timestamp = datetime.now().isoformat()
    log_msg = f"[{timestamp}] {message}"
    print(log_msg, flush=True)
    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
    with open(LOG_FILE, 'a') as f:
        f.write(log_msg + '\n')

def find_exploits_for_cve(cve_id):
    """Find all exploit files mentioning this CVE"""
    exploitdb_path = Path(EXPLOITDB_DIR)
    
    if not exploitdb_path.exists():
        return []
    
    matched_exploits = []
    
    # Search in exploits directory
    exploits_dir = exploitdb_path / "exploits"
    if not exploits_dir.exists():
        return []
    
    # Walk through all exploit files
    for exploit_file in exploits_dir.rglob("*"):
        if not exploit_file.is_file():
            continue
        
        # Only check code files
        if exploit_file.suffix not in ['.txt', '.py', '.rb', '.c', '.sh', '.pl', '.php', '.java']:
            continue
        
        try:
            # Read file and search for CVE
            content = exploit_file.read_text(errors='ignore')
            if cve_id in content:
                matched_exploits.append({
                    'file': str(exploit_file.relative_to(exploitdb_path)),
                    'language': exploit_file.suffix,
                    'size': exploit_file.stat().st_size,
                    'content': content[:10000]  # First 10KB
                })
        except Exception:
            continue
    
    return matched_exploits

def process_cve(cve_id):
    """Process one CVE"""
    output_file = Path(OUTPUT_DIR) / f"{cve_id}_matched.json"
    
    if output_file.exists():
        log(f"  {cve_id}: Already matched, skipping")
        return True
    
    log(f"  {cve_id}: Searching Exploit-DB...")
    
    # Find exploits
    exploits = find_exploits_for_cve(cve_id)
    
    if exploits:
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        data = {
            'cve': cve_id,
            'exploit_count': len(exploits),
            'exploits': exploits,
            'matched_at': datetime.now().isoformat(),
            'ready_for_variants': True
        }
        
        with open(output_file, 'w') as f:
            json.dump(data, f, indent=2)
        
        log(f"  {cve_id}: ✅ Found {len(exploits)} exploit(s)")
        return True
    else:
        log(f"  {cve_id}: ❌ Not found")
        return False

def main():
    """Main execution"""
    log("="*80)
    log("GLADIATOR CVE-TO-EXPLOIT MATCHER")
    log("="*80)
    
    # Check if Exploit-DB repo exists
    if not Path(EXPLOITDB_DIR).exists():
        log(f"\n❌ ERROR: Exploit-DB not found at {EXPLOITDB_DIR}")
        log("Run clone_exploitdb.sh first")
        return 0
    
    log(f"✅ Exploit-DB found at {EXPLOITDB_DIR}")
    
    # Load CVEs
    log(f"\nLoading CISA KEV from {CISA_KEV_FILE}")
    with open(CISA_KEV_FILE) as f:
        data = json.load(f)
    
    vulns = data.get('vulnerabilities', [])
    cves = [v.get('cveID') for v in vulns]
    
    log(f"Found {len(cves)} CVEs to match\n")
    
    # Match each CVE
    found = 0
    not_found = 0
    
    for i, cve in enumerate(cves, 1):
        log(f"[{i}/{len(cves)}] {cve}")
        
        if process_cve(cve):
            found += 1
        else:
            not_found += 1
        
        # Progress update
        if i % 50 == 0:
            log(f"  Progress: {i}/{len(cves)} ({i*100//len(cves)}%)")
            log(f"  Found: {found}, Not found: {not_found}\n")
    
    log("\n" + "="*80)
    log("CVE MATCHING COMPLETE")
    log(f"Total CVEs: {len(cves)}")
    log(f"Exploits found: {found}")
    log(f"Not found: {not_found}")
    log(f"Success rate: {found*100//len(cves)}%")
    log("="*80)
    
    return found

if __name__ == "__main__":
    try:
        count = main()
        sys.exit(0 if count > 0 else 1)
    except KeyboardInterrupt:
        log("\n\nMatching interrupted by user")
        sys.exit(130)
    except Exception as e:
        log(f"\n\nFATAL ERROR: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

